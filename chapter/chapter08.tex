%!TEX root = ../clcxsj.tex

\chapter{高斯投影正反算与换带}
\section{数据模型}
\subsection{投影换带的目的}
高斯投影是为解决球面与平面之间坐标映射问题的，即大地坐标(B,
L)与高斯平面直角坐标$(x,y)$之间的换算，以及不同带之间的高斯坐标
的换算问题。

本章将运用$C\#$编程语言编写一通用的高斯投影程序，用于1954北京坐标系、1980西安坐标系、
WGS84坐标系以及CGCS2000大地坐标系。

\subsection{高斯投影的主要内容}
\begin{enumerate}
    \item 坐标正算：将点的大地坐标转换成高斯投影平面直角坐标。
    \item 坐标反算：将点的高斯投影平面直角坐标转换成大地坐标。
    \item 换带计算：将某带的点的高斯投影平面直角坐标转换成邻带或某中央
      子午线经度的高斯投影平面直角坐标。
    \item 其他计算：计算子午线收敛角、长度比等。 
\end{enumerate}

\subsection{高斯投影的数学模型}

本章所引用的公式来自:
孔祥元,郭际明,刘宗泉.大地测量学基础-2版.武汉:武汉大学出版社,2010.5，
以下简称为大地测量学基础。

高斯投影是在椭球参数(长半轴a、短半轴b、扁率$\alpha$)一定的条件下，根据
给定的数学模型来进行计算的，我们首先分析这些计算公式。

\begin{enumerate}
 \item 基本公式

扁率：
$$\alpha=\frac{a-b}{a}$$

第一偏心率：
$$e=\sqrt{\frac{a^2-b^2}{a^2}}$$

第二偏心率：
$$e'=\sqrt{\frac{a^{2}-b^{2}}{b^{2}}}$$

子午圈曲率半径：
$$M=a(1-e^2)(1-e^2\sin ^2 B)^{-\frac{3}{2}}$$

卯酉圈曲率半径：
$$N=a(1-e^2\sin ^2 B)^{-\frac{1}{2}}$$
辅助符号：
$$t=\tan B\qquad\eta=e'\cos B$$

\item 子午线弧长
$$X=a_0 B - \frac{a_2}{2}\sin 2B + \frac{a_4}{4}\sin 4B 
- \frac{a_6}{6} \sin 6B  + \frac{a_8}{8}\sin 8B$$

式中：
\[
\left \{ \begin{aligned}
a_0 &= m_0 + \frac{m_2}{2} + \frac{3}{8}m_4 + \frac{5}{16}m_6 + \frac{35}{128}m_8  \\
a_2 &= \frac{m_2}{2} + \frac{m_4}{2} + \frac{15}{32}m_6 + \frac{7}{16}m_8  \\
a_4 &= \frac{m_4}{8} + \frac{3}{16}m_6 + \frac{7}{32}m_8  \\
a_6 &= \frac{m_6}{32} + \frac{m_8}{16}  \\
a_8 &= \frac{m_8}{128}
\end{aligned} \right.
\]

式中$m_0, m_2, m_4, m_6, m_8$的值为：
\[
\left \{ \begin{aligned}
m_0 &= a(1-e^2) \\
m_2 &= \frac{3}{2}e^2 m_0  \\
m_4 &= \frac{5}{4}e^2 m_2   \\
m_6 &= \frac{7}{6}e^2 m_4   \\
m_8 &= \frac{9}{8}e^2 m_6 
\end{aligned} \right.
\]

公式引用自《大地测量学基础》第115页(4-101)、(4-100)与(4-72).


\item 坐标正算
\[
\left \{ \begin{aligned}
x&=X+\frac{N}{2}sinBcosBl^2 +\frac{N}{24}sinBcos^3B(5-t^2 +9\eta^2+4\eta^4)l^4 \\
  &+\frac{N}{720}sinBcos^5 B(61-58t^2 +t^4)l^6  \\
y&=NcosBl+\frac{N}{6}cos^3 B(1-t^2 +\eta^2 )l^3 \\
        &+\frac{N}{120}cos^5 B (5-18t^2+t^4 +14\eta^2 -58\eta^2t^2)l^5
\end{aligned} \right.
\]


公式引用自《大地测量学基础》第169页(4-367)。

\item 坐标反算
\[
\left \{ \begin{aligned}
B&=B_f - \frac{t_f}{2M_f N_f }y^2 +\frac{t_f}{24 M_f N_f ^3}
(5 + 3t_f ^2  + \eta_f ^2 - 9\eta_f ^2 t_f^2)y^4 \\
 &- \frac{t_f}{720 M_f N_f ^5}(61 + 90t_f ^2 + 45t_f ^4)y^6 \\
l&=\frac{1}{N_f cosB_f}y - \frac{1}{6N_f ^3 cosB_f}(1 + 2t_f ^2 + \eta_f ^2)y^3  \\
 &+ \frac{1}{120N_f ^5 cosB_f}(5 + 28t_f ^2 + 24t_f ^4 + 6\eta_f ^2 +8\eta_f ^2 t_f ^2)y^5
\end{aligned} \right.
\]

公式引用自《大地测量学基础》第171页(4-383)。


\item 平面子午线收敛角计算

利用$(B, l)$计算公式如下：
$$\gamma = \sin B \cdot l + \frac{1 + 3 \eta^2 + 2 \eta^4}{3} \sin B \cos ^2 B \cdot l^3 
+ \frac{2 - t^2}{15}\sin B \cos ^4 B \cdot l^5$$

公式引用自《大地测量学基础》第181页(4-408)。

利用$(x, y)$计算公式如下：

$$\gamma = \frac{1}{N_f}t_f y - \frac{1+t_f ^2 - \eta_f ^2}{3N_f ^3}t_f y^3 
+ \frac{2+5t_f^2+3t_f^4}{15N_f ^5}t_fy^5$$

公式引用自《大地测量学基础》第182页(4-410)。

\item 长度比计算

利用$(B, l)$计算公式如下：
$$m=1+\frac{1}{2}l^2 \cos ^2 B(1+\eta^2) + \frac{1}{24}l^4\cos ^4 B(5-4t^2)$$

公式引用自《大地测量学基础》第189页(4-447)。

利用$(x, y)$计算公式如下：

$$m=1+\frac{y^2}{2R^2} + \frac{y^4}{24R^4}$$

式中$R=\sqrt{MN}$，公式引用自《大地测量学基础》第189页(4-451)。

\end{enumerate}

\subsection{数学模型分析}
分析以上各个计算公式发现，如果长半轴与扁率确定,参考椭球的第一偏心率$e$、
第二偏心率$e'$，辅助计算参数$(m_0, m_2, m_4, m_6, m_8)$与
$(a_0, a_2, a_4, a_6, a_8)$也就确定了。也就是说这些参数对于某一种确定的
参考椭球是常数。而$(M,N,t,\eta)$则是纬度$B$的函数。

\section{高斯投影基本功能实现}

为了让我们的算法能被其他项目使用，我们在此新建一 Class Library(.NET Framework) 项目，
在项目中将以前所写的 SMath.cs 文件加入，将命名空间
改为 ZXY 。

基于以上分析，我们新建一椭球类$(Ellipsoid)$，在其中我们定义以上与椭球类型
相关的元素。代码如下所示：
\begin{verbatim}
//File Ellipsoid.cs
using System;

namespace ZXY
{
    public class Ellipsoid
    {
        private double a;
        private double b;
        private double f; //(a-b)/a = 1/f

        private double e2;
        private double eT2;

        private double a0;
        private double a2;
        private double a4;
        private double a6;
        private double a8;

        private double m0;
        private double m2;
        private double m4;
        private double m6;
        private double m8;

        .................................
    }
}
\end{verbatim}

C语言是典型的面向过程设计语言，小巧、灵活，功能强大。
下面我们将从一个小功能开始构造满足以上全部功能的程序。

在此我们先完成正算功能，我们设定正算中所用的角度均为弧度，从而避免在正算中进行
度分秒与弧度的转换问题，我们也先把读数据文件、多点等问题去掉，从只计算
一个点开始考虑问题。我们现在只考虑54北京坐标系的问题，别的暂且不管。假
如我们的主函数的调用形式如下：
\begin{verbatim}
void main()
{
    //克拉索夫斯基参考椭球
    double a = 6378245.0,  f = 298.3;
    //正算点的纬度和经差
    double B = 0.3836189311, l = 0.0423314484;
    // B = 21°58′47.0845″ l = 2°25′31.4880″
    double x, y;
    CalEcd(a, f);
    GaussZs(B, l, &x, &y);
    printf("x = %lf, y = %lf \n", x, y);
    //算出的x=2433586.692， y=250547.403
}
\end{verbatim}

以上程序的流程为：

(1)给定一个类型的参考椭球：如长半轴a， 扁率f

(2)计算相关的参数：计算偏心率，子午线弧长系数等，这些相对于一个给定
的椭球来说，它是一个定值；

(3)根据给定的B，l 计算相应的高斯平面坐标；

(4)输出计算值。

从流程上可看出，GaussZs函数的原型如下：
\begin{verbatim}
void GaussZs(double B, double l,
             double * x, double * y)
\end{verbatim}
这里B，l为给定值，x，y设定为指针类型，用于返回计算后的值。下面我们来实
现这个函数，它的计算流程如下：

(1)计算子午线弧长；

(2)计算x和y坐标；

我们设计该函数如下：
\begin{verbatim}
void GaussZs(double B, double l,
             double * x, double * y)
{
    double sinB = sin( B );
    double cosB = cos( B );
    double cosB2 = cosB * cosB;
    double cosB4 = cosB2 * cosB2;
    double l2 = l * l;
    double l4 = l2 * l2;

    double g = _eT * cosB;
    double g2 = g * g;
    double g4 = g2 * g2;
    double t = tan(B);
    double t2 = t * t;
    double t4 = t2 * t2;

    //计算子午线弧长
    double X = MeridianArcLength( B );
    double N = _c / sqrt(1.0 + g2);

    *x = X + N * sinB * cosB * l2 *
    ( 0.5
      + cosB2 * l2 * (5.0 - t2 + 9.0 * g2 + 4.0 * g4) / 24.0
      + cosB4 * l4 * (61.0 - 58.0 * t2
          + t4 + 270.0 * g2 - 330.0 * g2 * t2)  / 720.0
    );
    *y = N * cosB * l *
    ( 1.0
      + cosB2 * l2 * (1.0 - t2 + g2) / 6.0
      + cosB4 * l4 * (5.0 - 18.0 * t2 + t4
          + 14.0 * g2 - 58.0 * t2 * g2) / 120.0
    );
}
\end{verbatim}

从函数的实现看，前面的变量只是为了简化后面的计算式，整个函数中没有逻辑
判断和循环，因此较为简单。但子午线弧长的计算函数MeridianArcLength(
double )我们还没实现，根据算法，它的实现如下：
\begin{verbatim}
double MeridianArcLength(double B)
{
    double sinB = sin(B);
    double cosB = cos(B);
    double sinB3 = sinB * sinB * sinB;
    double sinB5 = sinB * sinB * sinB3;
    double sinB7 = sinB * sinB * sinB5;
    return _A0 * B - cosB * (_B0 * sinB + _C0 * sinB3
           + _D0 * sinB5 + _E0 * sinB7);
}
\end{verbatim}
程序中的\verb|_A0、_B0、_C0、_D0、_E0|为子午线弧长计算的系数，在此我把它们设
为全局变量，在CalEcd函数中进行计算。如：

\begin{verbatim}
double _a, _b, _c, _d, _e, _eT;
double _A0, _B0, _C0 , _D0, _E0;
double _e2, _e4, _e6, _e8;
\end{verbatim}

由于这些相关的系数只与椭球的参数有关，我们只在函数CalEcd计算一次。其实
现如下：
\begin{verbatim}
void CalEcd(double a, double f)
{
    _a = a; _b = _a * (1.0 - 1.0 / f);

    _e = sqrt(_a * _a - _b * _b) / _a;
    _eT = sqrt(_a * _a - _b * _b) / _b;
    _c = _a / _b * _a;
    _d = _b / _a * _b;

    _e2 = _e * _e;
    _e4 = _e2 * _e2;
    _e6 = _e2 * _e4;
    _e8 = _e2 * _e6;

    _A0 = _d * (  1    + 3.0 /4.0 * _e2
                   + 45.0 / 64.0 * _e4
               + 175.0 / 256.0 * _e6
               + 11025.0 / 16384.0 * _e8 );
    _B0 = _d * (         3.0 /4.0 * _e2
                   + 45.0 / 64.0 * _e4
               + 175.0 / 256.0 * _e6
               + 11025.0 / 16384.0 * _e8);
    _C0 = _d * (         15.0 / 32.0 * _e4
               + 175.0 / 384.0 * _e6
                       + 3675.0 /  8192.0 * _e8);
    _D0 = _d * (         35.0 /  96.0 * _e6
                   + 735.0 /  2048.0 * _e8);
    _E0 = _d * (     315.0 /  1024.0 * _e8 );
}
\end{verbatim}

至此，我们完成了高斯平面直角坐标的正算功能的程序设计。为了利用C++语言
增强了的C功能，我们把文件的扩展名由c改为cpp，以利用C++编译器进行严格检
查。

为了进行源代码一级的复用，我们在工程中新加入一个头文件（.h），将上面除
主函数main()之外的所有代码剪切到头文件中（如头文件为Gauss.h），在主函
数所在的文件中将头文件包含在内，即在文件顶端加入：\verb|#include "Gauss.h"|，
在别的地方我们就可继续使用这些函数。

为了直接利用纬度、经度和中央子午线的经度计算高斯平面坐标，我们可以利用函数重
载的功能继续实现坐标正算：

\begin{verbatim}
void GaussZs(double B, double L, double L0,
             double * x, double * y)
{
    double l = L - L0;
    GaussZs(B, l, x, y);
}
\end{verbatim}

这里的实现很简单，只是计算了经差，调用了原来的正算函数。我们就可在主函
数中作如下形式的调用了：

\begin{verbatim}
void main()
{
    //21°58′47.0845″的弧度形式
    double B = 0.3836189311;
    // 113°25′31.4880″的弧度形式
    double L = 1.9796469181;
    // 111°的弧度形式
    double L0 = 1.9373154697;
    //54//x:2433586.692, y:250547.403
    GaussZs(B, L, L0, &x, &y);
    printf("x = %lf, y = %lf \n", x, y);
}
\end{verbatim}
至此，我们已经完成了高斯坐标正算的全部计算了。以上的函数调用中的角度均
使用了弧度的形式，利用前面所讲的角度化弧度的函数，我们可以以下形式的调
用：

\begin{verbatim}
void main()
{
    //21°58′47.0845″
    double B = DMStoRAD(21.58470845);
    //113°25′31.4880″
    double L = DMStoRAD (113.25314880);
    double L0 = DMStoRAD(111.0); //111°
    //54//x:2433586.692, y:250547.403
    GaussZs(B, L, L0, &x, &y);
    printf("x = %lf, y = %lf \n", x, y);
}
\end{verbatim}

同样，坐标反算的程序设计的实现方法也基本一样。由于面向过程的程序设计不
是我们的重点，就将这部分的实现放入面向对象中。

\section{*面向对象的高斯坐标正反算程序设计}
在前面的程序设计中，我们将椭球参数用全局变量表示，为了消除这些全局变量
的影响，我们采用类的形式对其进行封装，封装的形式如下：

\begin{verbatim}
class CEarth
{
private:
    double _a, _b, _c, _d, _e, _eT;
    double _A0, _B0, _C0 , _D0, _E0;
    double _e2, _e4, _e6, _e8, _e10;
};
\end{verbatim}

将它们设为private，防止类以外的代码随意访问它们。
再将上面实现的正算等函数作为其成员函数，则形式为：

\begin{verbatim}
class CEarth
{
private:
    double _a, _b, _c, _d, _e, _eT;
    double _A0, _B0, _C0 , _D0, _E0;
    double _e2, _e4, _e6, _e8, _e10;
public:
    CEarth();//构造函数
    virtual ~CEarth();  //析构函数
    //计算相关系数
    void CalEcd(double a, double alf);
    //正算
    void GsZs(double l, double B,
              double& x, double& y);
    void GsZs(double L, double B, double L0,
              double& x, double& y);
    //反算
    void GsFs(double x, double y,
              double& l, double& B);
    void GsFs(double x, double y, double L0,
              double & L, double & B);
    //子午线收敛角
    double MeridianConvergentAngleByBl(
              double l, double B);
    double MeridianConvergentAngleByxy(
              double x, double y);
    //子午线弧长
    double MeridianArcLength(double B);
     //底点纬度
    double Bf(double x);
};
\end{verbatim}

在类的成员函数定义中，将传进的参数用引用的形式加const进行限定，同时用
引用取代指针进行函数返回值，如GsZs，GsFs函数。

在这里，我们看看反算的实现。在反算的计算流程中，经差l的计算很简单，直
接计算即可，但纬度的计算需要先计算底点纬度，由于我们的程序是针对多种椭
球的，底点纬度的数值计算公式是不能使用的。我们用子午线弧长计算公式进行
迭代计算，在开始迭代时，取弧长的初值为\verb|x / _A0|，其具体实现如下：

\begin{verbatim}
double CEarth::Bf(double x)
{
    double Bf0 = x / _A0; //子午线弧长的初值
    int i = 0;
    while( i < 10000 )//设定迭代次数
    {
        double sinBf = sin(Bf0);
        double cosBf = cos(Bf0);
        double sinBf3 = sinBf * sinBf * sinBf;
        double sinBf5 = sinBf * sinBf * sinBf3;
        double sinBf7 = sinBf * sinBf * sinBf5;

        double Bf = (  x
                 + cosBf * ( _B0 * sinBf
                                + _C0 * sinBf3
                    + _D0 * sinBf5
                    + _E0 * sinBf7)
            ) / _A0;
        if( fabs(Bf - Bf0) < 1e-10) //计算精度
            return Bf;
        else
        {
            Bf0 = Bf;
            i++;
        }
    }
    return -1e12;
}
\end{verbatim}

反算的实现如下：

\begin{verbatim}
void CEarth::GsFs(double x, double y,
                  double & l, double & B)
{
    double Bf0 = Bf( x );
    double cosBf = cos( Bf0 );

    double gf = _eT * cosBf;
    double gf2 = gf * gf;
    double gf4 = gf2 * gf2;

    double tf = tan(Bf0);
    double tf2 = tf * tf;
    double tf4 = tf2 * tf2;

    double Nf = _c / sqrt(1.0 + gf2);
    double Nf2 = Nf * Nf;
    double Nf4 = Nf2 * Nf2;

    double y2 = y * y;
    double y4 = y2 * y2;

    l = y / (Nf * cosBf) *
    ( 1.0
      - y2 / (6.0 * Nf2) * (1.0 + 2.0 * tf2 + gf2)
          + y4 / (120.0 * Nf4 ) * (5.0
      + 28.0 * tf2
          + 24.0 * tf4
      + 6.0 * gf2
      + 8.0 * gf2 * tf2)
    );
    B = Bf0 - y2 / Nf2 * tf * 0.5 *
      ( (1.0 + gf2)
             - y2 * (5.0
                     + 3.0 * tf2
                     + 6.0 * gf2
                     - 6.0 * tf2 * gf2
                     - 3.0 * gf4
                     + 9.0 * gf4 * tf4
                    ) / (12.0 * Nf2)
             + y4 * (61.0
                     + 90.0 * tf2
                     + 45.0 * tf4
                     + 107.0 * gf2
                     + 162.0 * gf2 * tf2
                     + 45.0 * gf2 * tf4
                    ) / ( 360 * Nf4)
     );
}

//L：经度（弧度）, B：纬度（弧度）， L0：中央子午线经度
void CEarth::GsFs(double x, double y, double L0,
                  double& L, double& B)
{
    double l;
    GsFs(x, y, l, B);
    L = L0 + l;
}
\end{verbatim}

在以上实现中，由于我们的成员变量均为private类型，而构造函数为默认的形
式，无法将椭球的参数值传递进去。由于要实现54、80和自定义椭球的坐标系，
相应的解决方法有：

1．将默认的构造函数改为CEarth (double a, double alf)形式，将不同的椭球
参数传给类。比如要建立54坐标系，只需要如下作即可：
\begin{verbatim}
CEarth earth54(6378245.0, 298.3);
CEarth * pEarth54 = new CEarth(6378245.0, 298.3);
\end{verbatim}

这种形式很直观，但缺点也很明显，对于已知的常用椭球，编程人员每次均要提
供其具体的参数值，很不方便，也容易出错。

2．利用类厂的方法，将生成已知的常用椭球定义为静态成员函数，同时将构造
函数声明为private类型，防止象方法1那样直接访问。这种方法的优点是显而易
见的，它的实现如下：

在类CEarth中将默认的构造函数的访问域改为：
\begin{verbatim}
private:
    CEarth();
    void CalEcd(double a, double alf);
\end{verbatim}

同时CalEcd函数计算椭球内部的基本系数，不需要外部程序访问，也将其定义为
private。

同时在类中声明以静态成员指针变量：
\begin{verbatim}
private:
    static CEarth * _pEarth;
\end{verbatim}
在类的实现文件前面进行初始化：
\begin{verbatim}
CEarth* CEarth::_pEarth = NULL;
\end{verbatim}

再在类中定义用于创建椭球的静态成员函数：
\begin{verbatim}
public:
    static CEarth * CreateEarth54();
    static CEarth * CreateEarth80();
    static CEarth * CreateEarthCustomize(double a, double alf);
\end{verbatim}

它们的实现为：
\begin{verbatim}
CEarth * CEarth::CreateEarth54()
{
    if(_pEarth == NULL) _pEarth = new CEarth();
    _pEarth->CalEcd(6378245.0, 298.3);
    return _pEarth;
}
CEarth * CEarth::CreateEarth80()
{
    if(_pEarth == NULL) _pEarth = new CEarth();
    _pEarth->CalEcd(6378140.0, 298.257);
    return _pEarth;
}
CEarth * CEarth::CreateEarthCustomize(double a, double alf)
{
    if(_pEarth == NULL) _pEarth = new CEarth();
    _pEarth = new CEarth();
    _pEarth->CalEcd(a, alf);
    return _pEarth;
}
\end{verbatim}

从它们的实现看，是用new的方式生成了椭球对象，为了避免内存泄漏，类的析
构函数中，负责将申请的内存进行释放，它的实现如下：
\begin{verbatim}
CEarth::~CEarth()
{
    if(_pEarth != NULL)
    {
        delete _pEarth;
        _pEarth = NULL;
    }
}
\end{verbatim}

主函数调用的形式为：
\begin{verbatim}
void main()
{
    double x, y;
CEarth * pEarth = CEarth::CreateEarth54();
    double B = zx::CSurMath::DmsToRad(21.58470845);
    double l = zx::CSurMath::DmsToRad(113.25314880)
                   - zx::CSurMath::DmsToRad(111);
    pEarth->GsZs( l, B, x, y);
printf("x = %lf, y = %lf \n", x, y);
}
\end{verbatim}
现在我们基本上用面向对象的方法完成了高斯投影正反算的问题了。

\section{实现换带计算和文件读写}
\subsection{换带计算}
换带计算的基本方法：已知某一带（中央子午线经度已知oldL0）的点坐标
（oldX, oldY），利用高斯反算计算出大地坐标（B， L），再根据新带的中央
子午线经度（newL0），高斯正算计算新带中的高斯平面坐标（newX,  newY）。
用算法描述如下：

1．$（B，L）= GsFs(oldX, oldY, oldL0)$

2．$(newX,  newY) = GsZs(B, L, newL0)$

用一函数描述它为：
\begin{verbatim}
void CEarth::GsHd(double oldX, double oldY,
                  double oldL0,  double newL0,
                  double& newX, double& newY)
{
    double B, L;
    GsFs(oldX, oldY, oldL0, L, B);
    GsZs(L, B, newL0, newX, newY);
}
\end{verbatim}

注意：高斯换带计算一般是指同一参考椭球的不同带之间的换算，不同的参考椭
球的坐标系是不能采用这种方法的。

计算示例如下：

\begin{verbatim}
void main()
{
    double oldX = 3275110.535;
    double oldY = 235437.233;
    double oldL0 = zx::CSurMath::DmsToRad(117);
    double newL0 = zx::CSurMath::DmsToRad(120);
    double newX, newY;

   CEarth * pEarth = CEarth::CreateEarth54();
   pEarth->GsHd(oldX, oldY, oldL0, newL0, newX, newY);
   printf("newX = %lf,  newY = %lf \n", newX,  newY);
   // 3272782.315, -55299.545
}
\end{verbatim}

\subsection{多点计算和文件读写}
以上我们的算法和测试验证程序均是针对一个点而言的，如果我们在一个文本形
式的数据文件里存放有多个点，怎么计算呢？

1、我们设计正算的数据文件格式为：
\begin{verbatim}
成果文件名

转换点个数 ~ 中央子午线经度

点名 ~ 大地纬度 ~ 大地经度
\end{verbatim}

示例数据文件为：

\begin{verbatim}
BLXY.txt
3  111
p1  21.58470845  113.25314880
p2  31.04416832  111.47248974
p3  30.45254425  111.17583596
\end{verbatim}

则设计函数为：
\begin{verbatim}
struct PntInfo
{
    char name[10];
    double B, L;
    double x, y;
};
void Zs()
{
    double L0;//所在带的中央子午线经度
    int n;//转换点的个数
    char cg[256];//成果文件名
    FILE *in;
    //读取文本文件的数据
    in = fopen("BLtoXY.txt", "r"); //打开已知文件
    fscanf(in,"%s",cg); //首先读入成果文件名称
    fscanf(in,"%d %lf", &n, &L0); //转换点的个数  中央子午线经度
    PntInfo * pnts = new PntInfo[n];//动态数组
    for(int i = 0; i < n; i++)//循环读入点名B、L
        fscanf(in, "%s %lf %lf", pnts[i].name, &pnts[i].B, &pnts[i].L);
    fclose(in);
    //以下进行正算计算
    CEarth * pEarth = CEarth::CreateEarth54();
    for(i = 0; i < n; i++)
        pEarth->GsZs(zx::CSurMath::DmsToRad(pnts[i].L),
         zx::CSurMath::DmsToRad(pnts[i].B),
             zx::CSurMath::DmsToRad(L0),
         pnts[i].x, pnts[i].y);
    //将计算后的数据写到成果文件中
    FILE * out;
    out = fopen(cg, "w");
    fprintf(out, "大地坐标(B,L)=====>国家坐标(X,Y)\n ");
    fprintf(out,"中央子午线经度: L0 = %lf\n", L0);
    fprintf(out,"序号 点名 B      L ===> X坐标(m)  Y坐标(m)\n");
    for(i = 0; i < n; i++)
    {
    fprintf(out," %3d %s %lf %lf %11.3f %11.3f\n",
        i+1, pnts[i].name, pnts[i].B, pnts[i].L,
            pnts[i].x, pnts[i].y );
    }
    fclose(out);
    delete[] pnts;//释放申请的内存
}
\end{verbatim}

同样也可实现多点的数据文件反算和换带计算

反算的数据文件格式设为：XYBL.txt
\begin{verbatim}
3   111
p1     2433586.692   250547.403
p2     3439978.970    75412.872
p3     3404139.839    28680.571
\end{verbatim}

换带计算的数据文件格式设为：
\begin{verbatim}
XYBL.txt
3   111 112
p1     2433586.692   250547.403
p2     3439978.970    75412.872
p3     3404139.839    28680.571
\end{verbatim}
相应的实现请参照正算实现。

\section{小结}
我们从一个逻辑结构不太明显的程序开始，将其改为一个结构较好的面向过程的
程序。并从一个算法开始逐步实现了整个程序。最后用面向对象的方法将其改写
并实现了全部功能。最后的程序从结构上看明显要比第一个程序要好，且更易维
护和扩充。当然高斯换带计算较为简单，我们的程序实现同样也较为简单。从这
个例子，我们知道了怎样设计结构良好的程序。
